<!DOCTYPE HTML>
<html lang="kr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Casting SPELs (Clojure) 한국어판</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Casting SPELs (Clojure) 한국어판">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Index.html">들어가면서</a></li><li class="chapter-item expanded affix "><li class="part-title">Casting SPELs (Clojure)</li><li class="chapter-item expanded "><a href="lisperati/01_casting.html">캐스팅</a></li><li class="chapter-item expanded "><a href="lisperati/02_syntax.html">신텍스</a></li><li class="chapter-item expanded "><a href="lisperati/03_data.html">데이터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lisperati/03_data-cont.html">아톰</a></li></ol></li><li class="chapter-item expanded "><a href="lisperati/04_looking.html">둘러보기</a></li><li class="chapter-item expanded "><a href="lisperati/05_walking.html">돌아다녀보기</a></li><li class="chapter-item expanded "><a href="lisperati/06_spels.html">스펠 외우기</a></li><li class="chapter-item expanded "><a href="lisperati/07_actions.html">특별한 액션 만들기</a></li><li class="chapter-item expanded "><a href="lisperati/09_cheat.html">치트</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="ending.html">맺으며</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Casting SPELs (Clojure) 한국어판</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lispkorea/casting-spels-clojure" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="들어가면서"><a class="header" href="#들어가면서">들어가면서</a></h1>
<ul>
<li><code>이 글은 옮긴이가 내용 구성 및 표현의 효과를 위하여 원전과 다소 다르게 더하거나 뺀 부분이 있음을 알립니다.</code></li>
</ul>
<p><img src="./res/casting_spels.jpg" alt="" /></p>
<ul>
<li>원저자: Conrad Barski, M.D.</li>
<li>편역: netpyoung</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casting-spels-clojure"><a class="header" href="#casting-spels-clojure">Casting SPELs (Clojure)</a></h1>
<ul>
<li><a href="https://www.lisperati.com/casting.html">원문</a></li>
</ul>
<p>리스프(Lisp, 리슾)를 아는 사람이라면, 리스프가 다른 프로그래밍 언어들과 매우 다르다고 말할 것입니다.
이는 실로 놀라울 정도로 많이 다릅니다. 이 만화를 통해 리스프가 얼마만큼 강력한지, 리스프의 독특한 디자인을 통해 배워보도록 하겠습니다.</p>
<p><img src="lisperati/../res/different.jpg" alt="" /></p>
<p>리스프 언어에는 여러가지 종류가 있는데, 그 중 클로저로 진행하도록 하겠습니다.</p>
<p><code>clj</code> 명령어를 통해 클로저의 REPL을 실행합니다.</p>
<pre><code class="language-clojure">$ clj
Clojure 1.11.1
user=&gt;
</code></pre>
<p>REPL은 <code>R</code>ead <code>E</code>val <code>P</code>rint <code>L</code>oop의 약자입니다. REPL은 사용자가 입력한 코드를 읽고, 실행하고, 결과를 출력하고, 다시 반복합니다.</p>
<pre><code class="language-clojure">user=&gt; (+ 1 2)
3
user=&gt;
</code></pre>
<p><code>user=&gt;</code>에서 <code>user</code>는 현재 네임스페이스의 이름입니다. 네임스페이스안에서 정의한 함수/변수들은 네임스페이스에 저장됩니다. <code>ns</code>는 <code>n</code>ame<code>s</code>pace의 약자이며, 네임스페이스를 바꿀 수 있는 매크로 입니다.</p>
<p>다음과 같이 <code>(ns spel)</code>로 네임스페이스를 <code>spel</code>로 바꿀 수 있습니다.</p>
<pre><code class="language-clojure">user=&gt; (ns spel)
nil
spel=&gt;
</code></pre>
<p>REPL을 종료하려면</p>
<ul>
<li>Window에서는 Ctrl-z를</li>
<li>macOs/Linux에서는 Ctrl-d를 누르면 됩니다.</li>
</ul>
<h2 id="짚고넘어갈것"><a class="header" href="#짚고넘어갈것">짚고넘어갈것</a></h2>
<ul>
<li><a href="https://clojure.org">클로저(Clojure)</a></li>
<li>clj 명령어</li>
<li>REPL 종료법</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="신택스-그리고-시맨틱"><a class="header" href="#신택스-그리고-시맨틱">신택스 그리고 시맨틱</a></h1>
<ul>
<li><a href="https://www.lisperati.com/syntax.html">원문</a></li>
</ul>
<p>모든 컴퓨터 언어는 <strong>신택스(Syntax, 문법/구조론)</strong> 와 <strong>시맨틱(Semantic, 의미론)</strong> 으로 이루어진 코드를 가지고 있습니다.</p>
<p><strong>신택스</strong> 는 프로그램에서 컴파일러가 무엇이 무엇인지 알 수 있도록 따라야만 하는 프로그래밍 언어의 기본 빼대입니다. 이로써 무엇이 함수인지, 변수인지 등을 알 수 있습니다. </p>
<p><strong>시맨틱</strong> 은 프로그램의 좀 더 &quot;랜덤&quot;한 내용을 다룹니다. 프로그램의 특정 지점에서 어떤 변수가 사용가능한지 아닌지 같은 것들이 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>syntax &amp; semantics</th><th></th></tr></thead><tbody>
<tr><td>Syntax</td><td>어떻게 구성되어야 하는가</td></tr>
<tr><td>Semantics</td><td>어떻게 동작하는가</td></tr>
</tbody></table>
</div>
<p>리스프의 첫 번째로 특별한 부분은 메이저 프로그래밍 언어 중 가장 간결한 신택스를 가지고 있다는 점입니다. 기본적으로 리스프 신택스는 리스프 컴파일러에게 넘겨주는 텍스트를 리스트(list)로 넘기도록 강제합니다. 필요에 따라 중첩된 리스트 역시 가능합니다.</p>
<p>리스트의 시작과 끝은 괄호로 되어있습니다:</p>
<pre><code class="language-clojure">;; 쌍번점(`;`)는 주석을 의미합니다.

(list 1 2 3)
</code></pre>
<p><img src="lisperati/../res/list.jpg" alt="" /></p>
<p>추가적으로, 리스프 컴파일러는 두가지 모드를 사용하여 코드를 읽습니다: 코드 모드와 데이터 모드</p>
<p>데이터 모드일때, 리스트에 아무거나 넣을 수 있습니다. 그러나, 컴파일러는 코드 모드에서 코드를 읽기 시작합니다.</p>
<div class="table-wrapper"><table><thead><tr><th>모드</th><th>리스트</th></tr></thead><tbody>
<tr><td>코드</td><td>리스트를 <code>코드</code>로 읽고 실행된다</td></tr>
<tr><td>데이터</td><td>리스트를 <code>데이터</code> 자체로 취급한다.(실행하지 않는다)</td></tr>
</tbody></table>
</div>
<p>코드 모드에서는 리스트는 <strong>&quot;폼(form)&quot;</strong> 이라 불리는 특별한 형태의 리스트여야만 합니다.</p>
<p><img src="lisperati/../res/frame.jpg" alt="" /></p>
<p>폼은 리스트이며, 이 리스트의 첫번째 심볼이 컴파일러가 이해할 수 있는 특별한 단어여야 합니다 - 보통은 함수의 이름이며, 컴파일러는 리스트의 나머지 부분을 함수의 인자로 넘김니다. 그리고 이러한 인자들을 읽을때, 데이타 모드로 변환하라고 지정하지 않는한, 코드 모드라 가정하고 읽습니다.</p>
<h2 id="짚고넘어갈것-1"><a class="header" href="#짚고넘어갈것-1">짚고넘어갈것</a></h2>
<ul>
<li>신택스와 시맨틱</li>
<li>코드모드와 데이터모드</li>
<li>리스트</li>
<li>폼</li>
<li>주석(<code>;</code>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="게임-세상을-위한-데이타-정의하기"><a class="header" href="#게임-세상을-위한-데이타-정의하기">게임 세상을 위한 데이타 정의하기</a></h1>
<ul>
<li><a href="https://www.lisperati.com/data.html">원문</a></li>
</ul>
<p>폼에 대해 더 이해하기 위해, 폼으로 우리가 만들 게임 세상을 데이타화 시켜봅시다.</p>
<p>우선, 게임에는 플레이어가 집고 사용가능한 오브젝트(Object)들이 있습니다 - 이러한 오브젝트들을 정의해 봅시다:</p>
<pre><code class="language-clojure">(def 상수_리스트_모든오브젝트 '(:위스키병 :양동이 :개구리 :사슬))
</code></pre>
<p>자, 이제 이 줄을 분석하고 그 의미를 살펴봅시다: 리스프 컴파일러는 항상 <code>코드 모드</code>에서 읽기 시작하고 형식을 기대하기 때문에 첫 번째 기호인<code>def</code>를 명령어 라고 간주합니다.
<code>def</code>는 define 즉 정의하다의 약자입니다.
이 명령어는 주어진 값으로 변수를 설정합니다: 변수 이름은 <code>상수_리스트_모든오브젝트</code>이며, 키워드로된 오브젝트들이 리스트안에 들어있습니다.
편의상 변하지 않는 변수 이름 앞에 <code>상수_</code>를 붙였습니다.
이 리스트는 데이타이므로, <code>:위스키병</code>가 명령어로써 실행되지 않게 하기 위해 컴파일러를 데이타 모드로 변환시킬 필요가 있습니다.
리스트 앞의 붙은 따옴표(<code>'</code>)는 컴파일러를 변형시키기 위한 명령어입니다.</p>
<p>오브젝트 이름 앞에 콜론(<code>:</code>)이 붙어 있는데, 클로저(Clojure)언어에서는 이를 키워드(keyword)라 합니다. 키워드는 심볼(symbol)에 비해 비교하는 연산에서 빠릅니다.</p>
<p><img src="lisperati/../res/objects.jpg" alt="" /></p>
<p>이제 게임 세상에 쓰일 오브젝트들을 정의해 봤습니다. 이제 더 나아가서 게임 세상의 지도를 정의해 보겠습니다. 여기에 게임 세상이 어떻게 생겼는지 나와있는 그림이 있습니다:</p>
<p><img src="lisperati/../res/world.jpg" alt="" /></p>
<p>이 간단한 게임에는 3개의 다른 장소가 있습니다: <code>거실</code>과 <code>다락방</code>을 가진 집이 있으며 그리고 <code>정원</code>도 있습니다.</p>
<p>이제 게임 세상을 표현하는 <code>상수_전체지도</code>라는 새로운 변수를 정의해 봅시다:</p>
<pre><code class="language-clojure">(def 상수_전체지도
  {:거실
   {:설명
    &quot;[마법사의 집 - `거실`]: `마법사`가 소파에 코를 골며 자고있다.&quot;
    :사전_경로 {:서쪽 [:문 :정원]
                :위층 [:계단 :다락방]}}

   :다락방
   {:설명
    &quot;[마법사의 집 - `다락방`]: 구석에 `용접`을 할 수 있는 화로가 있다&quot;
    :사전_경로 {:아래층 [:계단 :거실]}}}

   :정원
   {:설명
    &quot;[아름다운 `정원`]: `우물`이 앞에 보인다&quot;
    :사전_경로 {:동쪽 [:문 :거실]}})
</code></pre>
<p>이 지도는 우리가 알고 싶은 세 곳에 대한 모든 중요한 내용을 담고 있습니다:</p>
<ul>
<li>장소를 나타내는 고유한 이름 (예: 거실, 다락방, 정원)</li>
<li>그리고 그곳에서 볼 수 있는 것에 대한 간단한 설명</li>
<li>해당 장소로의 입출입 경로의 위치와 방법.</li>
</ul>
<p>이 변수는 더도 덜도 아닌 딱 우리가 알아야 되는 정보만을 담고 있습니다. 리스퍼는 군더더기를 빼고 보기만 해도 이해하기 쉬운 작고 간결한 코드를 작성하는 것을 좋아합니다</p>
<p>앞선 리스트와 달리, 괄호모양이 조금 다른것을 알 수 있습니다. 사전(dictionary)과 벡터(vector)를 사용하여 이 정보를 표현했습니다.</p>
<ul>
<li>벡터는 리스트와 비슷하지만, 중괄호 대신 대괄호(<code>[ ]</code>)로 둘러싸여 있습니다.</li>
<li>사전(dictionary)은 키와 값으로 되어있는 컬렉션(collection)입니다. 리스트와 비슷하게 중괄호(<code>{ }</code>)로 둘러싸여 있습니다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>컬렉션</th><th>기호</th><th>예</th><th>big-O</th></tr></thead><tbody>
<tr><td>리스트(list)</td><td><code>( )</code></td><td><code>(1 2 3)</code></td><td>O(n)</td></tr>
<tr><td>벡터(vector)</td><td><code>[ ]</code></td><td><code>[1 2 3]</code></td><td>O(1)</td></tr>
<tr><td>사전(dictionary, 딕션어리)</td><td><code>{ }</code></td><td><code>{:a 1 :b 2 :c 3}</code></td><td>O(1)</td></tr>
</tbody></table>
</div>
<p>그리고 문자열은 따옴표(<code>&quot; &quot;</code>)로 둘러싸여 있습니다.</p>
<p>이제 지도와 오브젝트 목록이 있으니, 각각의 오브젝트가 지도상의 장소 어디에 있는지 알 수 있는 변수를 선언해 봅시다:</p>
<pre><code class="language-clojure">(def 상수_사전_오브젝트_랑_장소
  {:위스키병 :거실
   :양동이   :거실
   :사슬     :정원
   :개구리   :정원})
</code></pre>
<p>여기서, 사전을 만들어서 오브젝트랑 장소를 각각 연결하였습니다.
이 사전은 오브젝트를 키로, 장소를 값으로 가지고 있습니다. 그리고 이 장소는 지도의 키로도 쓰입니다.
여기 <code>:거실</code>, <code>:정원</code>, <code>:다락방</code> 이라는 장소를 나타내는 세 개의 키가 있습니다.</p>
<p>게임 세상과 그 안에 있는 오브젝트들을 정의했으니, 이제 게임 플레이어의 장소만 남았습니다.</p>
<pre><code class="language-clojure">(def 상수_플레이어_시작_장소
  :거실)
</code></pre>
<p>자, 이제 게임에 쓰일 게임 커맨드들을 만들러 갑시다!</p>
<p><img src="lisperati/../res/drink.jpg" alt="" /></p>
<h2 id="짚고넘어갈것-2"><a class="header" href="#짚고넘어갈것-2">짚고넘어갈것</a></h2>
<ul>
<li><a href="https://clojuredocs.org/clojure.core/def">def</a></li>
<li>키워드(<code>:</code>)</li>
<li>리스트(<code>( )</code>)</li>
<li>벡터(<code>[ ]</code>)</li>
<li>사전(<code>{ }</code>)</li>
<li>문자열(<code>&quot; &quot;</code>)</li>
<li>데이터를 간결하게 추리기</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="게임-세상을-위한-데이타-정의하기---계속"><a class="header" href="#게임-세상을-위한-데이타-정의하기---계속">게임 세상을 위한 데이타 정의하기 - 계속</a></h1>
<p>앞서 <code>def</code>를 이용해서 정의한 변수는 상수라고 했습니다. 즉, 한번 정의되면 그 값을 바꿀 수 없습니다.</p>
<p>그런데 게임에서는 상수가 아닌 변수가 필요합니다. 예를 들어 플레이어가 어떤 물건을 들고 있을때, 그 물건을 다른 물건으로 바꾸거나, 물건을 버릴 수 있어야 합니다.</p>
<p>클로저에는 이렇게 상태를 가지는 변수를 지정 할 수 있는 여러가지 타입들을 제공합니다. 그중에서도 가장 간단한 <code>atom</code>을 이용해서 변수를 정의해 보겠습니다.</p>
<p>편의상 <code>atom</code>변수는 <code>atom_</code>를 붙여서 정의하도록 하겠습니다.</p>
<pre><code class="language-clojure">;; 변수.
(def atom_플레이어_사전_오브젝트_랑_장소
  (atom 상수_사전_오브젝트_랑_장소))

(def atom_플레이어_현재장소
  (atom 상수_플레이어_시작_장소))

(def atom_플레이어_사슬을_용접하였는가
  (atom false))

(def atom_플레이어_양동이를_채웠는가
  (atom false))
</code></pre>
<p>아래는 <code>atom</code>의 간단한 사용법입니다.</p>
<pre><code class="language-clojure">&gt; (def atom_테스트 (atom 1))
&gt; atom_테스트
#object[clojure.lang.Atom 0x4aac85fa {:status :ready, :val 1}]

;; atom의 값을 가져오려면 deref를 사용
&gt; (deref atom_테스트)
=&gt; 1

;; deref와 @는 같은 의미
&gt; @atom_테스트
=&gt; 1

;; 강제로 셋팅
&gt; (reset! atom_테스트 2)
&gt; @atom_테스트
=&gt; 2

;; 함수 적용
&gt; (swap! atom_테스트 + 1 2 3)
&gt; @atom_테스트
=&gt; 8
</code></pre>
<p>이제 플레이어 정보를 초기화 시켜주는 함수 역시 정의해 보겠습니다.</p>
<pre><code class="language-clojure">(defn 초기화 []
  (reset! atom_플레이어_사전_오브젝트_랑_장소 상수_사전_오브젝트_랑_장소)
  (reset! atom_플레이어_현재장소              상수_플레이어_시작_장소)
  (reset! atom_플레이어_사슬을_용접하였는가   false)
  (reset! atom_플레이어_양동이를_채웠는가     false)
  :초기화완료)
</code></pre>
<p><code>defn</code>은 <code>define function</code>의 약자로 함수를 정의합니다. 여기서는 아무런 인자도 받지 않고 있습니다. <code>초기화</code>함수는 플레이어의 atom변수들을 초기화하는 역할을 합니다.</p>
<h2 id="짚고넘어갈것-3"><a class="header" href="#짚고넘어갈것-3">짚고넘어갈것</a></h2>
<ul>
<li><a href="https://clojuredocs.org/clojure.core/atom">atom</a></li>
<li><a href="https://clojuredocs.org/clojure.core/deref">deref</a>, @</li>
<li><a href="https://clojuredocs.org/clojure.core/reset!">reset!</a></li>
<li><a href="https://clojuredocs.org/clojure.core/swap!">swap!</a></li>
<li><a href="https://clojuredocs.org/clojure.core/defn">defn</a></li>
</ul>
<h2 id="참고"><a class="header" href="#참고">참고</a></h2>
<ul>
<li><a href="https://clojure.wladyka.eu/posts/share-state/">https://clojure.wladyka.eu/posts/share-state/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="게임-세상-둘러보기"><a class="header" href="#게임-세상-둘러보기">게임 세상 둘러보기</a></h1>
<ul>
<li><a href="https://www.lisperati.com/looking.html">원문</a></li>
</ul>
<p>이제 게임에 사용할 게임 커맨드들을 만들어 보도록 하겠습니다.</p>
<p>가장 먼저 필요한 게임 커맨드는 현재 있는 장소에 대해 알려주는 <code>둘러보기</code> 커맨드입니다.
그렇다면 게임 세상에서의 장소를 설명하는 커맨드에 어떤 정보들을 넣어야 할까요?
설명하고자 하는 장소를 지도에서 찾을 수 있어야 합니다.</p>
<p>이 함수가 바로 그 역할을 합니다:</p>
<pre><code class="language-clojure">(defn 정보얻기-장소 [지도 장소]
  (-&gt; 지도
      (get 장소)
      :설명))

;; 아래도 동일한 역활을 하는 함수입니다.
;; (defn 정보얻기-장소 [지도 장소]
;;   (:설명 (get 지도 장소)))
</code></pre>
<ul>
<li><code>-&gt;</code>는 <code>thread-first</code>라고 불리는 매크로입니다.
<ul>
<li>이 매크로는 함수를 연결하여 함수의 결과를 다음 함수의 <code>첫 번째</code> 매개 변수로 전달합니다.</li>
<li>(<code>(-&gt; 1 (* 2 (+ 3 4)))</code>은  <code>(* 2 1 (+ 3 4))</code>와 같습니다.)</li>
<li>매크로에 대해서 다루는 것은 나중으로 미루겠습니다.</li>
</ul>
</li>
<li><code>get</code>함수는 지도에서 해당 장소에 대한 정보를 찾아줍니다.</li>
<li>그런 다음 키 <code>:설명</code>을 사용하여 설명을 찾습니다.
<ul>
<li><code>(get 장소)</code>와 같이 <code>:설명</code>을 <code>(get :설명)</code>으로 해도 동일합니다.</li>
</ul>
</li>
</ul>
<p>함수 이름은 <code>정보얻기-장소</code>이며 <code>지도</code>와 <code>장소</code>라는 두 개의 매개 변수를 사용합니다.
이제 장소가 거실이라고 가정해 봅시다.
거실의 설명을 찾으려면, 먼저 지도에서 거실을 가리키는 지점을 찾아야 합니다.</p>
<p>이제 앞서 정의한 상수와 함수를 프롬프트를 사용하여 테스트해 보겠습니다.</p>
<pre><code class="language-clojure">&gt; (정보얻기-장소 상수_전체지도 :거실)

&quot;[마법사의 집 - `거실`]: `마법사`가 소파에 코를 골며 자고있다.&quot;
</code></pre>
<p>완벽합니다! 바로 우리가 원했던 것입니다.</p>
<p><img src="lisperati/../res/living_room.jpg" alt="" /></p>
<h2 id="함수형-프로그래밍-스타일"><a class="header" href="#함수형-프로그래밍-스타일">함수형 프로그래밍 스타일</a></h2>
<p>사람에 따라 <code>정보얻기-장소</code> 함수가 여러 가지 면에서 어색해 보일 수 도 있습니다.
우선, 글로벌 변수를 직접 읽지 않고 위치 및 지도 변수를 파라미터로 전달했습니다.
그 이유는 리스퍼들은 <strong>함수형 프로그래밍 스타일</strong> 로 코드를 작성하는 것을 좋아하기 때문입니다 (&quot;절차적 프로그래밍&quot; 또는 &quot;구조적 프로그래밍&quot;이라는 개념과는 전혀 관련이 없습니다...). 
이 스타일에서는 목표는 다음 규칙을 따르는 함수를 작성하는 것입니다:</p>
<ul>
<li>함수에 전달되거나 함수에 의해 생성된 변수만 읽습니다.
<ul>
<li>(따라서 전역 변수는 읽지 않습니다.)</li>
</ul>
</li>
<li>이미 설정된 변수의 값은 절대 변경하지 않습니다.
<ul>
<li>(따라서 변수 증가나 기타 어리석은 짓을 하지 않습니다.)</li>
</ul>
</li>
<li>결과값을 반환하는 것 외에는 외부 세계와 상호작용하지 않습니다.
<ul>
<li>(따라서 파일에 대한 쓰기, 사용자에 대한 메시지 쓰기가 불가능합니다.)</li>
</ul>
</li>
</ul>
<p>이러한 잔인한 제약을 따른다고해서 실제로 유용한 코드를 작성할 수 있는지 궁금할 수 있을 것입니다... 대답은 <strong>예</strong> 입니다.</p>
<p>그렇다면 이러한 규칙을 따라야 하는 이유는 무엇일까요?</p>
<p>매우 중요한 이유가 하나 있습니다: 이 스타일로 코드를 작성하면 프로그램에 <strong>참조 투명성(referential transparency)</strong> 이 부여됩니다. 즉, 동일한 매개변수로 호출된 특정 코드가 언제 호출해도 항상 동일한 결과를 반환하고 동일한 작업을 수행합니다. 이는 프로그래밍 오류를 줄일 수 있으며 대다수의 경우 프로그래머의 생산성을 향상시킬 수 있다고 여겨집니다.</p>
<p>물론 함수형 스타일에 맞지 않거나 사용자 또는 외부 세계와 소통할 수 밖에 없는 함수들이 항상 존재할 것입니다.
이 튜토리얼의 뒷부분에 나오는 대부분의 함수 역시 이 규칙을 따르지 않습니다.
이 함수에서 또 다른 문제점을 알아보자면, 장소와 장소사이를 들어오고 나갈 수 있는 경로를 알려주지 않는다는 것입니다.
자 이제 경로를 설명하는 함수가 필요한데, 일단 함수를 정의하기 앞서 앞선 <code>상수_전체지도</code>의 <code>:거실</code>의 <code>:사전_경로</code>에서 경로를 하나 살펴보겠습니다.</p>
<pre><code class="language-clojure">&gt; (seq {:서쪽 [:문 :정원] :위층 [:계단 :다락방]}})
([:서쪽 [:문 :정원]] [:위층 [:계단 :다락방]])

&gt; (first (seq {:서쪽 [:문 :정원] :위층 [:계단 :다락방]}}))
[:서쪽 [:문 :정원]]
</code></pre>
<ul>
<li><code>seq</code>는 <code>sequence</code>의 약자로 여기서는 사전(dictionary)의 키와 값의 쌍을 시퀀스로 변환합니다.</li>
<li><code>first</code>는 시퀀스의 첫 번째 요소를 반환합니다.</li>
</ul>
<p>자 이제부터 <code>[:서쪽 [:문 :정원]]</code>와 같은 모양 즉 <code>[방향 [통로 목적지]]</code>와 같은 형태를 경로라고 부르겠습니다.
이 경로를 설명하는 함수를 작성해 보겠습니다.</p>
<pre><code class="language-clojure">(defn 정보얻기-경로 [경로]
  (let [[방향 [통로 목적지]] 경로
        방향이름             (name 방향)
        통로이름             (name 통로)]
    (format &quot;`%s`으로 가는 %s이 있다&quot; 방향이름 통로이름)))
</code></pre>
<ul>
<li><code>let</code>은 지역 변수를 정의하는데 사용됩니다. 지역 변수는 괄호 안에서 정의되며, 괄호 밖에서는 사용할 수 없습니다.
<ul>
<li><code>(let [a 1 b 2] (+ a b))</code> -&gt;  <code>3</code></li>
<li><code>(let [[a b] [1 2]] (+ a b))</code> -&gt; <code>3</code></li>
</ul>
</li>
<li><code>name</code>은 매개 변수로 전달된 키워드를 문자열로 변환합니다.
<ul>
<li>ex) <code>(name :서쪽)</code> -&gt; <code>&quot;서쪽&quot;</code></li>
</ul>
</li>
<li><code>format</code> 함수는 문자열을 생성하는데 사용됩니다. 이 함수는 문자열 안에 <code>%s</code>와 같은 특수한 문자열을 사용하여 문자열을 생성합니다.
<ul>
<li>ex) <code>(format &quot;Hello %s&quot; &quot;world&quot;)</code> -&gt; <code>&quot;Hello world&quot;</code></li>
</ul>
</li>
</ul>
<pre><code class="language-clojure">&gt; (정보얻기-경로 [:서쪽 [:문 :정원]])

&quot;`서쪽`으로 가는 문이 있다&quot;
</code></pre>
<p>하나의 경로를 설명할 수 있지만 게임 내 장소에는 둘 이상의 경로가 있을 수 있으므로 <code>정보얻기-경로들</code>이라는 함수를 작성해 보겠습니다.</p>
<pre><code class="language-clojure">(defn 정보얻기-경로들 [지도 장소]
  (-&gt;&gt; (get 지도 장소)
       :사전_경로
       (mapv 정보얻기-경로)))
</code></pre>
<ul>
<li>
<p><code>-&gt;&gt;</code>는 <code>thread-last</code>라고 불리는 매크로입니다.</p>
<ul>
<li>이 매크로는 함수를 연결하여 함수의 결과를 다음 함수의 <code>마지막</code> 매개 변수로 전달합니다.</li>
<li>ex) <code>(-&gt;&gt; 1 (* 2 (+ 3 4)))</code>은  <code>(* 2 (+ 3 4) 1)</code>와 같습니다.</li>
<li>매크로에 대해서 다루는 것은 나중으로 미루겠습니다. </li>
</ul>
</li>
<li>
<p>이 함수는 또 다른 <strong>함수형 프로그래밍(functional programming)</strong> 기법을 사용합니다: <strong>고차 함수(high-order function)</strong></p>
<ul>
<li>즉, <code>mapv</code> 함수는 다른 함수를 매개변수로 받아 내부적으로 호출할 수 있습니다.</li>
<li><code>mapv</code>는 함수와 시퀀스를 매개변수를 받아, 시퀀스의 각 항목에 함수를 적용한 결과를 반환합니다(결과 타입은 벡터)
<ul>
<li>ex) <code>(mapv inc [1 2 3])</code> -&gt; `[2 3 4]</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>(mapv 정보얻기-경로 시퀀스)</code>는 시퀀스에 있는 모든 경로에 대해 <code>정보얻기-경로</code> 함수를 적용해 벡터로 반환합니다.</p>
<p>이 새로운 함수틀 테스트 해봅시다:</p>
<pre><code class="language-clojure">&gt; (정보얻기-경로들 상수_전체지도 :거실)

[&quot;`서쪽`으로 가는 문이 있다&quot;
 &quot;`위층`으로 가는 계단이 있다&quot;]
</code></pre>
<p>훌륭합니다!</p>
<p>아직 한 가지 더 정보를 얻어야만 하는 것이 남아있습니다: 우리가 서 있는 장소의 바닥에 있는 오브젝트에 대한 정보 역시 얻을 수 있도록 합시다.</p>
<p>먼저 아이템이 지정된 위치에 있는지 여부를 알려주는 헬퍼 함수를 작성해 보겠습니다.</p>
<pre><code class="language-clojure">(defn 오브젝트가-해당-장소에있는가? [사전_오브젝트_랑_장소 오브젝트 장소]
  (-&gt; 사전_오브젝트_랑_장소
      (get 오브젝트)
      (= 장소)))
</code></pre>
<p><code>사전_오브젝트_랑_장소</code>에서 <code>오브젝트</code>로 <strong>사전 속 장소</strong>를 얻어와, <strong>인자로 넘겨준 장소</strong>와 비교합니다.</p>
<p><img src="lisperati/../res/slob.jpg" alt="" /></p>
<p>한 번 시도해 보겠습니다:</p>
<pre><code>&gt; (오브젝트가-해당-장소에있는가? 상수_오브젝트_랑_장소 :위스키 :거실)

true
</code></pre>
<p>거실에 위스키 병이 있는 것이 있다 라는 것은 <code>true</code> 즉 참입니다. <code>false</code>는 거짓을 의미합니다.</p>
<p>이제 이 함수를 사용하여 바닥에 대한 정보를 얻어보도록 하겠습니다:</p>
<pre><code class="language-clojure">(defn 정보얻기-바닥 [사전_오브젝트_랑_장소 리스트_오브젝트 장소]
  (letfn [(오브젝트가_있나? [오브젝트]
            (오브젝트가-해당-장소에있는가? 사전_오브젝트_랑_장소 오브젝트 장소))]
    (-&gt;&gt; 리스트_오브젝트
         (filter 오브젝트가_있나?)
         (mapv #(format &quot;`%s`(이/가) 바닦에 있다&quot; (name %))))))
</code></pre>
<ul>
<li><code>fn</code>
<ul>
<li>ex) <code>(fn [x] (* x x))</code> -&gt; <code>#(* % %)</code></li>
<li>ex) <code>((fn [x] (* x x)) 2)</code> -&gt; <code>4</code></li>
</ul>
</li>
<li><code>letfn</code>
<ul>
<li><code>letfn</code>은 <code>let</code>과 유사하지만 함수를 정의하는데 씁니다.</li>
<li>ex) <code>(letfn [(square [x] (* x x))] (square 2))</code> -&gt; <code>4</code></li>
</ul>
</li>
<li><code>filter</code>
<ul>
<li>ex) <code>(filter even? [1 2 3 4])</code> -&gt; <code>[2 4]</code></li>
</ul>
</li>
</ul>
<p>이제 <strong>둘러보기</strong> 라는 하나의 커맨드로 이 모든 정보얻기 함수들을 어우러 묶어 보도록 하겠습니다:</p>
<pre><code class="language-clojure">(defn 둘러보기
  ([]
   (둘러보기
     상수_리스트_모든오브젝트
     상수_전체지도
     @atom_플레이어_사전_오브젝트_랑_장소
     @atom_플레이어_현재장소))
  ([리스트_오브젝트
    지도
    플레이어_사전_오브젝트_랑_장소
    플레이어_현재장소]
   (-&gt; [(정보얻기-장소 지도 플레이어_현재장소)
        (정보얻기-경로들 지도 플레이어_현재장소)
        (정보얻기-바닥 플레이어_사전_오브젝트_랑_장소 리스트_오브젝트 플레이어_현재장소)]
       (flatten)
       (vec))))
</code></pre>
<p><code>둘러보기</code>는 인자를 아에 안받거나 4개를 받습니다. <code>defn</code>은 이와같이 인자에 갯수가 달라짐에 따른 <strong>함수오버로딩(function overloading)</strong> 을 지원합니다.</p>
<ul>
<li><code>flatten</code>
<ul>
<li>ex) <code>(flatten [[1 2] [3 4]])</code> -&gt; <code>[1 2 3 4]</code></li>
</ul>
</li>
<li><code>vec</code>
<ul>
<li>ex) <code>(vec '(1 2 3))</code> -&gt; <code>[1 2 3]</code></li>
</ul>
</li>
</ul>
<p><img src="lisperati/../res/functional.jpg" alt="" /></p>
<p>한번 둘러보겠습니다:</p>
<pre><code class="language-clojure">&gt; (둘러보기)

[&quot;[마법사의 집 - `거실`]: `마법사`가 소파에 코를 골며 자고있다.&quot;
 &quot;`서쪽`으로 가는 문이 있다&quot;
 &quot;`위층`으로 가는 계단이 있다&quot;
 &quot;`위스키병`(이/가) 바닦에 있다&quot;
 &quot;`양동이`(이/가) 바닦에 있다&quot;]
</code></pre>
<p>꽤 쩝니다!</p>
<h2 id="짚고넘어갈것-4"><a class="header" href="#짚고넘어갈것-4">짚고넘어갈것</a></h2>
<ul>
<li><a href="https://clojuredocs.org/clojure.core/seq">seq</a></li>
<li><a href="https://clojuredocs.org/clojure.core/first">first</a> / <a href="https://clojuredocs.org/clojure.core/last">last</a></li>
<li><a href="https://clojuredocs.org/clojure.core/let">let</a></li>
<li><a href="https://clojuredocs.org/clojure.core/name">name</a></li>
<li><a href="https://clojuredocs.org/clojure.core/format">format</a></li>
<li>고차 함수(high-order function)</li>
<li>함수오버로딩(function overloading)</li>
<li><a href="https://clojuredocs.org/clojure.core/map">map</a></li>
<li><a href="https://clojuredocs.org/clojure.core/mapv">mapv</a></li>
<li><a href="https://clojuredocs.org/clojure.core/fn">fn</a></li>
<li><a href="https://clojuredocs.org/clojure.core/filter">filter</a></li>
<li><a href="https://clojuredocs.org/clojure.core/-%3E">-&gt;</a>: thread-first</li>
<li><a href="https://clojuredocs.org/clojure.core/-%3E%3E">-&gt;&gt;</a>: thread-last</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="만들어진-세상-돌아다녀보기"><a class="header" href="#만들어진-세상-돌아다녀보기">만들어진 세상 돌아다녀보기</a></h1>
<ul>
<li><a href="https://www.lisperati.com/walking.html">원문</a></li>
</ul>
<p>이제 게임 세상에 무엇이 있는지 알 수 있게 되었으니, 이 안에서 걸어 다닐 수 있는 코드를 작성해 보겠습니다.
편의상 상태를 변경하는 (사이드 이펙트)함수 이름의 끝에 <code>!</code>를 붙이도록 하겠습니다.</p>
<p>함수형 스타일이 아닌 사이드 이펙트를 지닌 <code>방향으로걷기!</code> 함수는 방향을 지정하고 그 방향으로 걸어갈 수 있게 해줍니다.</p>
<pre><code class="language-clojure">(defn 방향으로걷기! [방향]
  (let [다음으로 (-&gt;&gt; atom_플레이어_현재장소
                      deref
                      상수_전체지도
                      :사전_경로
                      방향)]
    (if 다음으로
      (let [[_ 장소] 다음으로]
        (reset! atom_플레이어_현재장소 장소)
        (둘러보기))
      [&quot;그쪽으로 갈 수 없습니다&quot;])))
</code></pre>
<ul>
<li><code>if</code> 함수는 조건이 참이면 첫 번째 매개변수를 실행하고 거짓이면 두 번째 매개변수를 실행합니다.
<ul>
<li>ex) <code>(if true &quot;참&quot; &quot;거짓&quot;)</code> -&gt; <code>&quot;참&quot;</code></li>
</ul>
</li>
</ul>
<pre><code class="language-clojure">&gt; (방향으로걷기! :서쪽)

[&quot;[아름다운 `정원`]: `우물`이 앞에 보인다&quot;
 &quot;`동쪽`으로 가는 문이 있다&quot;
 &quot;`개구리`(이/가) 바닦에 있다&quot;
 &quot;`사슬`(이/가) 바닦에 있다&quot;]
</code></pre>
<p><code>방향으로걷기!</code>함수에선 키워드 <code>:서쪽</code>을 사용하였습니다. 사용자가 입력하기 편하게 하기 위해 키워드가 아닌 그냥 <code>서쪽</code>을 입력하면 어떨까요?
코드 모드에서 <code>서쪽</code>을 입력하면 평가중에 서쪽이라는 변수가 없다고 오류가 발생할 것입니다. 그렇다고 데이터 모드로 바꾸려면 따옴표(<code>'</code>)를 사용해야 합니다.</p>
<p><code>:</code>의 입력을 피하니 <code>'</code>를 입력하라니... <code>'</code>없이 <code>서쪽</code>이라는 단어를 데이터로 사용할 방법은 없을까요?</p>
<h2 id="짚고넘어갈것-5"><a class="header" href="#짚고넘어갈것-5">짚고넘어갈것</a></h2>
<ul>
<li><a href="https://clojuredocs.org/clojure.core/if">if</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="스펠-외우기"><a class="header" href="#스펠-외우기">스펠 외우기</a></h1>
<ul>
<li><a href="https://www.lisperati.com/spels.html">원문</a></li>
</ul>
<p>자, 이제 리스프의 놀랍도록 강력한 기능을 배워보겠습니다: SPEL 만들기!</p>
<p>스펠(마법, <code>SPEL</code>)은 <code>S</code>emantic <code>P</code>rogram <code>E</code>nhancement <code>L</code>ogic의 줄임말로,  필요에 맞게 리스프 언어 자체를 변경할 수 있게 만들어 줍니다. 리스프에서 가장 마법처럼 보이는 부분입니다.</p>
<p>스펠을 사용하려면 먼저 리스프 컴파일러 내에서 스펠을 활성화 시켜야 합니다.</p>
<pre><code class="language-clojure">(defmacro def-스펠 [&amp; rest]
  `(defmacro ~@rest))
</code></pre>
<p>좋습니다. 이제 활성화 되었습니다. 이제 첫 스펠<code>이동</code>을 외워봅시다:</p>
<pre><code class="language-clojure">(def-스펠 이동 [방향]
  `(방향으로걷기! ~(keyword 방향)))
</code></pre>
<ul>
<li><code>keyword</code>
<ul>
<li>ex) <code>(keyword '서쪽)</code> =&gt; <code>:서쪽</code></li>
</ul>
</li>
</ul>
<p>이 코드가 하는 일은 리스프 컴파일러에게 <code>이동</code>라는 단어가 실제로는 <code>방향으로걷기!</code>라는 단어이며, 내부적으로 인자로 들어온 방향(ex <code>서쪽</code>)을 키워드방향(ex <code>:서쪽</code>)으로 만들어 줍니다.
코드를 완전히 컴파일하기 전에 다른 것으로 변경하는 특수한 코드를 프로그램과 컴파일러 사이에 몰래 삽입할 수 있습니다:</p>
<p><img src="lisperati/../res/spel_compile.jpg" alt="" /></p>
<p>리스프에서는 코드와 데이터가 거의 동일하게 보입니다. 매우 일관되고 깔끔한 디자인입니다! 새로운 스펠을 사용해 봅시다:</p>
<pre><code class="language-clojure">&gt; (이동 서쪽)
;; (방향으로걷기! :서쪽)

[&quot;[아름다운 `정원`]: `우물`이 앞에 보인다&quot;
 &quot;`동쪽`으로 가는 문이 있다&quot;
 &quot;`개구리`(이/가) 바닦에 있다&quot;
 &quot;`사슬`(이/가) 바닦에 있다&quot;]
</code></pre>
<p>훨씬 나아졌습니다!</p>
<p>이제 게임 세상에서 오브젝트를 집는 함수를 만들어 보도록 하겠습니다:</p>
<pre><code class="language-clojure">(defn 오브젝트-집기! [오브젝트]
  (let [오브젝트이름 (name 오브젝트)]
    (if-not (오브젝트가-해당-장소에있는가? @atom_플레이어_사전_오브젝트_랑_장소 오브젝트 @atom_플레이어_현재장소)
      [(format &quot;여기에는 `%s`(이/가) 없습니다&quot; 오브젝트이름)]
      (do
        (swap! atom_플레이어_사전_오브젝트_랑_장소 assoc 오브젝트 :주인공-인벤토리)
        [(format &quot;`%s`(을/를) 집어들었습니다&quot; 오브젝트이름)]))))
</code></pre>
<p>이 함수는 오브젝트가 실제로 현재 위치의 바닥에 있는지 확인하고, 만약 그렇다면 <code>atom_플레이어_사전_오브젝트_랑_장소</code>를 갱신하고, 성공 여부를 알려주는 문장을 반환합니다.
갱신할때 <a href="lisperati/./03_data-cont.html">앞서 배운</a> <code>swap!</code> 함수를 활용했습니다.
<code>atom_플레이어_사전_오브젝트_랑_장소</code>에 <code>assoc</code> 함수를 적용시키며, 인자로는 <code>오브젝트</code>와 <code>:주인공-인벤토리</code>를 넘겨주었습니다.</p>
<p>이 함수도 앞선 <code>방향으로걷기!</code>와 같이 키워드를 인자로 받기에, <code>이동</code> 스펠처럼 좀 더 쉽게 사용할 수 있는 다른 스펠을 시전해 보겠습니다:</p>
<pre><code class="language-clojure">(def-스펠 집어들기 [오브젝트]
  `(오브젝트-집기! ~(keyword 오브젝트)))
</code></pre>
<p>이제 새로운 스펠을 사용해 봅시다:</p>
<pre><code class="language-clojure">&gt; (집어들기 위스키)

[&quot;`위스키병`(을/를) 집어들었습니다&quot;]
</code></pre>
<p>이제 유용한 함수 몇개 더 추가해 보도록 하겠습니다. 우선 현재 플레이어가 가지고 있는 오브젝트 목록을 볼 수 있는 함수를 만들어 보겠습니다:</p>
<pre><code class="language-clojure">(defn 플레이어-오브젝트-리스트-가져오기 []
  (filter #(오브젝트가-해당-장소에있는가? @atom_플레이어_사전_오브젝트_랑_장소 % :주인공-인벤토리) 상수_리스트_모든오브젝트))
</code></pre>
<p>이제 플레이어가 특정 오브젝트를 가지고 있는지 알려주는 함수를 만들어 보겠습니다:</p>
<pre><code class="language-clojure">(defn 가지고있는가? [오브젝트]
  (-&gt;&gt; (플레이어-오브젝트-리스트-가져오기)
       (some #{오브젝트})
       (some?)))
</code></pre>
<p><code>some</code>과 <code>some?</code> 함수가 보입니다. 이 둘의 차이점은 무엇일까요?</p>
<ul>
<li><code>some</code>: 함수를 콜렉션의 각 요소에 적용하여, 평가 결과가 nil/fase가 아닌게 나오면 그 평가결과를 반환합니다.
<ul>
<li>ex) <code>(some even? '(1 2 3 4))</code> =&gt; <code>true</code>, <code>(some even? '(1 3))</code> =&gt; <code>nil</code></li>
</ul>
</li>
<li><code>some?</code>: nil이면 false, 아니면 true
<ul>
<li>ex) <code>(some? nil)</code> =&gt; <code>false</code></li>
</ul>
</li>
</ul>
<p>some함수의 반환값이 <code>nil</code>이 나올 수 있기에, 마지막에 <code>some?</code>을 사용하여 <code>true/false</code>로 변환해 주었습니다.</p>
<h2 id="짚고넘어갈것-6"><a class="header" href="#짚고넘어갈것-6">짚고넘어갈것</a></h2>
<ul>
<li><a href="https://clojuredocs.org/clojure.core/defmacro">defmacro</a>
<ul>
<li><code>'</code>: <a href="https://clojuredocs.org/clojure.core/quote">quote</a></li>
<li>` : back-quoting</li>
<li><code>~</code>: <a href="https://clojuredocs.org/clojure.core/unquote">unquote</a></li>
<li><code>~@</code>: <a href="https://clojuredocs.org/clojure.core/unquote-splicing">unquote-splicing</a></li>
</ul>
</li>
<li><a href="https://clojuredocs.org/clojure.core/if">keyword</a></li>
<li><a href="https://clojuredocs.org/clojure.core/do">do</a></li>
<li><a href="https://clojuredocs.org/clojure.core/assoc">assoc</a></li>
<li><a href="https://clojuredocs.org/clojure.core/dissoc">dissoc</a></li>
<li><a href="https://clojuredocs.org/clojure.core/some">some</a></li>
<li><a href="https://clojuredocs.org/clojure.core/some_q">some?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="특별한-액션-만들기"><a class="header" href="#특별한-액션-만들기">특별한 액션 만들기</a></h1>
<ul>
<li><a href="https://www.lisperati.com/actions.html">원문</a></li>
</ul>
<p>이제 한단계만 더 넘으면 게임이 완성됩니다: 플레이어가 게임에서 승리하기 위해 수행해야 하는 몇 가지 특별한 행동을 게임에 추가합니다. 
첫 번째 커맨드는 다락방에 있는 양동이에 사슬을 용접하는 것입니다:</p>
<pre><code class="language-clojure">(defn 용접 [오브젝트 대상]
  (if-not (and (= @atom_플레이어_현재장소 :다락방)
               (= 오브젝트 :사슬)
               (= 대상 :양동이)
               (가지고있는가? 오브젝트))
    [&quot;그렇게 용접 할 수는 없습니다&quot;]
    (if-not (가지고있는가? :양동이)
      [&quot;`양동이`를 가지고 있지 않습니다.&quot;]
      (do
        (reset! atom_플레이어_사슬을_용접하였는가 true)
        [&quot;`사슬`이 `양동이`에 단단히 용접되었습니다.&quot;]))))
</code></pre>
<p>먼저 이 작업을 이미 수행했는지 여부를 알 수 있는 새로운 전역 변수를 만들었습니다. 다음으로 용접에 적합한 조건이 모두 갖추어졌는지 확인하고 용접할 수 있는 용접 커맨드를 만들었습니다.</p>
<p><img src="lisperati/../res/weld.jpg" alt="" /></p>
<p>새로운 커맨드를 사용해 봅시다:</p>
<pre><code class="language-clojure">&gt; (용접 :사슬 :양동이)

[&quot;그렇게 용접 할 수는 없습니다&quot;]
</code></pre>
<p>이런... 우리는 양동이나 사슬이 없습니다. 그리고 주위에 용접할만 장치도 없습니다... 뭐 괜찮습니다...</p>
<p>이제 사슬을 건 양동이로 우물을 기르는 커맨드를 만들어 봅시다:</p>
<pre><code class="language-clojure">(defn 물기르기 [오브젝트 대상]
  (if-not (and (= @atom_플레이어_현재장소 :정원)
               (= 오브젝트 :양동이)
               (= 대상 :우물)
               (가지고있는가? 오브젝트))
    [&quot;그렇게 물기르기 할 수는 없습니다&quot;]
    (if-not @atom_플레이어_사슬을_용접하였는가
      [&quot;물에 닿지 않습니다.&quot;]
      (do
        (reset! atom_플레이어_양동이를_채웠는가 true)
        [&quot;`양동이`에 물을 가득 채웠습니다.&quot;]))))
</code></pre>
<p>눈치챘는지 모르겠지만 이 커맨드가 앞선 <code>용접</code> 커맨드와 매우 유사하다는 것을 알 수 있습니다... 두 커맨드 모두 오브젝트, 대상, 장소를 확인하는데 두 커맨드를 하나의 함수로 합치기에는 무리처럼 보입니다. 유감스럽습니다... ...만 리스프이기에 단순히 함수를 추가시켜 나가는게 아니라, 스펠을 외울 수 있습니다! 다음 스펠을 만들어 봅시다:</p>
<pre><code class="language-clojure">(def-스펠 def-액션 [커맨드명 [액션오브젝트 액션대상] 액션장소 &amp; 액션본체]
  (let [키워드_액션오브젝트# (keyword 액션오브젝트)
        키워드_액션대상#     (keyword 액션대상)]
    `(def-스펠 ~커맨드명 [오브젝트# 대상#]
       (let [키워드_오브젝트# (keyword 오브젝트#)
             키워드_대상#     (keyword 대상#)]
         `(if-not (and (= @atom_플레이어_현재장소 ~'~액션장소)
                       (= ~키워드_오브젝트# ~'~키워드_액션오브젝트#)
                       (= ~키워드_대상# ~'~키워드_액션대상#)
                       (가지고있는가? ~'~키워드_액션오브젝트#))
            ~[(str &quot;그렇게 &quot; '~커맨드명 &quot;할 수는 없습니다&quot;)]
            ~@'~액션본체)))))
</code></pre>
<p>헛웃음이 나올 정도로 복잡한 스펠입니다. 리스트보다 따옴표, 역따옴표, 쉼표 및 기타 이상한 기호(<code>#</code>, `, <code>~</code>, <code>~@</code>)가 더 많아 보입니다.
뿐만 아니라 스펠이 스펠을 만들고 있습니다!
숙련된 리스프 프로그래머라도 이런 괴물을 만들기 위해선 약간의 고민을 해야 할 것입니다.</p>
<p><img src="lisperati/../res/game_action.jpg" alt="" /></p>
<p>이 스펠에서의 요점은 이 스펠로 얼마나 정교하고 창의적인 것들을 얻을 수 있는지 보여주는 것입니다.
또, 한 번만 작성해서 더 큰 어드벤처 게임에서 수  백 개의 커맨드를 만들 수 있다면, 못생긴 것은 그리 중요하지 않습니다.</p>
<p>새로운 스펠을 사용하여 못생긴 용접 커맨드를 교체해봅시다:</p>
<pre><code class="language-clojure">(def-액션 용접 [사슬 양동이]
  :다락방
  (if-not (가지고있는가? :양동이)
    [&quot;`양동이`를 가지고 있지 않습니다.&quot;]
    (do
      (reset! atom_플레이어_사슬을_용접하였는가 true)
      [&quot;`사슬`이 `양동이`에 단단히 용접되었습니다.&quot;])))
</code></pre>
<p>이 얼마나 쉽게 이해할 수 있게 됬나요. 액션 스펠을 사용하면 원하는 내용을 간결하고 정확하게 작성할 수 있습니다. 마치 게임 커맨드를 만들기 위해 자신만의 컴퓨터 언어를 만든 것과 같습니다.
스펠과 같이 자신만의 의사 언어를 만드는 것을 <strong>도메인 특정 언어 프로그래밍(DSL, Domain Specific Language)</strong> 라고 하는데, 이는 빠르고 우아하게 프로그래밍 할 수 있는 매우 강력한 접근법입니다.</p>
<pre><code class="language-clojure">&gt; (용접 사슬 양동이)

[&quot;그렇게 용접 할 수는 없습니다&quot;]
</code></pre>
<p>...여전히 용접을 할 수 있는 상태는 아니지만, 커맨드는 잘 동작하고 있습니다!</p>
<p><img src="lisperati/../res/dunk.jpg" alt="" /></p>
<p>다음으로, 물기르기 커맨드도 다시 작성해 봅시다:</p>
<pre><code class="language-clojure">(def-액션 물기르기 [양동이 우물]
  :정원
  (if-not @atom_플레이어_사슬을_용접하였는가
    [&quot;물에 닿지 않습니다.&quot;]
    (do
      (reset! atom_플레이어_양동이를_채웠는가 true)
      [&quot;`양동이`에 물을 가득 채웠습니다.&quot;])))  
</code></pre>
<p><img src="lisperati/../res/splash.jpg" alt="" /></p>
<p>그리고 마지막으로 마법사에게 물을 끼얹는 코드입니다:</p>
<pre><code class="language-clojure">(def-액션 끼얹기 [양동이 마법사]
  :거실
  (cond
    (not @atom_플레이어_양동이를_채웠는가)
    [&quot;`양동이`가 비어있습니다&quot;]

    (가지고있는가? :개구리)
    [&quot;`마법사`는 당신이 `개구리`를 훔친 것을 알아챘습니다.&quot;
     &quot;그는 매우 화가나서, `당신`을 지옥으로 보내버렸습니다.&quot;
     &quot;실패! 게임 끝.&quot;]

    :else
    [&quot;`마법사`는 잠에서 깨고, `당신`을 따뜻히 맞아주었습니다.&quot;
     &quot;그는 (저탄수)도넛을 `당신`에게 건냈습니다.&quot;
     &quot;성공! 게임 끝.&quot;]))
</code></pre>
<ul>
<li><code>cond</code>는 if와 비슷하지만 여러가지 조건과 행동을 가질 수 있습니다.
<ul>
<li>ex) <code>(cond (= 1 2) &quot;1과 2는 같습니다.&quot; (= 1 1) &quot;1과 1은 같습니다.&quot; :else &quot;모든 조건이 거짓입니다.&quot;)</code> -&gt; <code>&quot;1과 1은 같습니다.&quot;</code></li>
</ul>
</li>
</ul>
<p><img src="lisperati/../res/donut.jpg" alt="" /></p>
<p><strong>마침내 텍스트 어드벤처 게임이 완성되었습니다!</strong></p>
<ul>
<li>게임에 대한 전체 공략을 보려면 <a href="lisperati/./09_cheat.html">여기</a>를 클릭합니다.</li>
<li>소스 코드의 사본을 보려면 <a href="lisperati/../code/src/spel.clj">여기</a>를 클릭합니다.</li>
</ul>
<p>이 튜토리얼을 최대한 간단하게 만들기 위해 리스프의 동작 방식에 대한 세부 사항들을 건너띄었으므로, 이제 그것들이 무엇인지 한번 살펴 보도록 하겠습니다...</p>
<h2 id="짚고넘어갈것-7"><a class="header" href="#짚고넘어갈것-7">짚고넘어갈것</a></h2>
<ul>
<li><a href="https://clojuredocs.org/clojure.core/and">and</a></li>
<li><a href="https://clojuredocs.org/clojure.core/str">str</a></li>
<li><a href="https://clojuredocs.org/clojure.core/cond">cond</a></li>
<li>nested macro</li>
<li>도메인 특정 언어 프로그래밍(DSL, Domain Specific Language)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-clojure">&gt; (둘러보기)
[&quot;[마법사의 집 - `거실`]: `마법사`가 소파에 코를 골며 자고있다.&quot;
 &quot;`서쪽`으로 가는 문이 있다&quot;
 &quot;`위층`으로 가는 계단이 있다&quot;
 &quot;`위스키병`(이/가) 바닦에 있다&quot;
 &quot;`양동이`(이/가) 바닦에 있다&quot;]

&gt; (집어들기 양동이)
[&quot;`양동이`(을/를) 집어들었습니다&quot;]

&gt; (플레이어-오브젝트-리스트-가져오기)
(:양동이)

&gt; (이동 위층)
[&quot;[마법사의 집 - `다락방`]: 구석에 `용접`을 할 수 있는 화로가 있다&quot;
 &quot;`아래층`으로 가는 계단이 있다&quot;]

&gt; (이동 동쪽)
[&quot;그쪽으로 갈 수 없습니다&quot;]

&gt; (이동 아래층)
[&quot;[마법사의 집 - `거실`]: `마법사`가 소파에 코를 골며 자고있다.&quot;
 &quot;`서쪽`으로 가는 문이 있다&quot;
 &quot;`위층`으로 가는 계단이 있다&quot;
 &quot;`위스키병`(이/가) 바닦에 있다&quot;]

&gt; (이동 서쪽)
[&quot;[아름다운 `정원`]: `우물`이 앞에 보인다&quot;
 &quot;`동쪽`으로 가는 문이 있다&quot;
 &quot;`개구리`(이/가) 바닦에 있다&quot;
 &quot;`사슬`(이/가) 바닦에 있다&quot;]

&gt; (물기르기 양동이 우물)
[&quot;물에 닿지 않습니다.&quot;]

&gt; (집어들기 사슬)
[&quot;`사슬`(을/를) 집어들었습니다&quot;]

&gt; (플레이어-오브젝트-리스트-가져오기)
(:양동이 :사슬)

&gt; (이동 동쪽)
[&quot;[마법사의 집 - `거실`]: `마법사`가 소파에 코를 골며 자고있다.&quot;
 &quot;`서쪽`으로 가는 문이 있다&quot;
 &quot;`위층`으로 가는 계단이 있다&quot;
 &quot;`위스키병`(이/가) 바닦에 있다&quot;]

&gt; (끼얹기 양동이 마법사)
[&quot;`양동이`가 비어있습니다&quot;]

&gt; (이동 위층)
[&quot;[마법사의 집 - `다락방`]: 구석에 `용접`을 할 수 있는 화로가 있다&quot;
 &quot;`아래층`으로 가는 계단이 있다&quot;]

&gt; (용접 사슬 양동이)
[&quot;`사슬`이 `양동이`에 단단히 용접되었습니다.&quot;]

&gt; (이동 아래층)
[&quot;[마법사의 집 - `거실`]: `마법사`가 소파에 코를 골며 자고있다.&quot;
 &quot;`서쪽`으로 가는 문이 있다&quot;
 &quot;`위층`으로 가는 계단이 있다&quot;
 &quot;`위스키병`(이/가) 바닦에 있다&quot;]

&gt; (이동 서쪽)
[&quot;[아름다운 `정원`]: `우물`이 앞에 보인다&quot;
 &quot;`동쪽`으로 가는 문이 있다&quot;
 &quot;`개구리`(이/가) 바닦에 있다&quot;]

&gt; (물기르기 양동이 우물)
[&quot;`양동이`에 물을 가득 채웠습니다.&quot;]

&gt; (이동 동쪽)
[&quot;[마법사의 집 - `거실`]: `마법사`가 소파에 코를 골며 자고있다.&quot;
 &quot;`서쪽`으로 가는 문이 있다&quot;
 &quot;`위층`으로 가는 계단이 있다&quot;
 &quot;`위스키병`(이/가) 바닦에 있다&quot;]

&gt; (끼얹기 양동이 마법사)
[&quot;`마법사`는 잠에서 깨고, `당신`을 따뜻히 맞아주었습니다.&quot;
 &quot;그는 (저탄수)도넛을 `당신`에게 건냈습니다.&quot;
 &quot;성공! 게임 끝.&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="맺으며"><a class="header" href="#맺으며">맺으며</a></h1>
<p><a href="https://lisperati.com/clojure-spels/casting.html">원문</a>에서는 커먼 리스프를 기준으로 설명했지만, 여기서는 클로저를 기준으로 설명했습니다.
뿐만아니라 커먼 리스프에서 리스트로만 데이터를 다루는 것을 유용하게 생각하는 딕션어리나 벡터로 바꾸어 넣었습니다. </p>
<p>다른 언어로 구현된 <code>Casting SPEL</code>도 역시 확인해보세요.</p>
<div class="table-wrapper"><table><thead><tr><th>Casting SPEL</th></tr></thead><tbody>
<tr><td><a href="https://www.lisperati.com/casting.html">common lisp </a></td></tr>
<tr><td><a href="https://www.lisperati.com/clojure-spels/casting.html">clojure</a></td></tr>
<tr><td><a href="http://rubyquiz.com/quiz49.html">ruby</a></td></tr>
<tr><td><a href="https://jpmoresmau.blogspot.com/2006/11/my-first-haskell-adventure-game.html">hasekll</a></td></tr>
<tr><td><a href="https://cnbbooks.github.io/lfe-casting-spels/">lfe</a></td></tr>
</tbody></table>
</div>
<ul>
<li>리스프에 관심이 있어 클로저를 설치하고 싶으신 분이 있으시다면 <a href="https://lispkorea.github.io/clojure/setup_clojure/">링크</a> 한번 방문해 주세요.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
